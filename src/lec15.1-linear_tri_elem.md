## Linear Triangle Elements

In previous discussions, we learned to calculate $\Psi$ and its derivatives with respect to $\mathbf{F}$. For simulation, however, we require $\frac{\partial \Psi}{\partial x}$ and $\frac{\partial^2 \Psi}{\partial x^2}$. This necessitates a clear understanding of $\mathbf{F}(x)$, as it allows us to employ the chain rule to derive these derivatives with respect to $x$ effectively.

In 2D simulations, we often divide the solid domain into non-degenerate triangular elements. Assume the mapping $\mathbf{x} = \phi(\mathbf{X})$ is linear within each triangle, thus keeping the deformation gradient $\mathbf{F}$ constant. Referencing {{ref: exp:lec12:deformation_gradient}}, for a triangle defined by vertices $\mathbf{X}_1\mathbf{X}_2\mathbf{X}_3$, we have the equations:
$$
\mathbf{x}_2 - \mathbf{x}_1 = \mathbf{F} (\mathbf{X}_2 - \mathbf{X}_1) \quad \text{and} \quad
\mathbf{x}_3 - \mathbf{x}_1 = \mathbf{F} (\mathbf{X}_3 - \mathbf{X}_1),
$$
where $\mathbf{x}_i$ denotes the world-space coordinates of the triangle vertices. This relationship leads to the expression for $\mathbf{F}$:
$$
\mathbf{F} = [\mathbf{x}_2 - \mathbf{x}_1, \mathbf{x}_3 - \mathbf{x}_1] [\mathbf{X}_2 - \mathbf{X}_1, \mathbf{X}_3 - \mathbf{X}_1]^{-1}.
{{numeq}}{eq:lec15:compute_F}
$$
Equation {{eqref: eq:lec15:compute_F}}  shows that $\mathbf{F}$, derived here, maps any segment within the triangle to its world-space counterpart through linear combinations of the triangle edges $\mathbf{X}_2 - \mathbf{X}_1$ and $\mathbf{X}_3 - \mathbf{X}_1$. A more general and rigorous derivation of this formula will be presented in subsequent chapters.

Once $\mathbf{F}(x)$ is established, we can calculate its derivative with respect to $x$ for each triangle as follows:
$$
\frac{\partial [\mathbf{F}_{11}, \mathbf{F}_{21}, \mathbf{F}_{12}, \mathbf{F}_{22}]^T}{\partial [\mathbf{x}_1^T, \mathbf{x}_2^T, \mathbf{x}_3^T]^T} =
\begin{bmatrix}
    -\mathbf{B}_{11} - \mathbf{B}_{21} & 0 & \mathbf{B}_{11} & 0 & \mathbf{B}_{21} & 0 \\
    0 & -\mathbf{B}_{11} - \mathbf{B}_{21} & 0 & \mathbf{B}_{11} & 0 & \mathbf{B}_{21} \\
    -\mathbf{B}_{12} - \mathbf{B}_{22} & 0 & \mathbf{B}_{12} & 0 & \mathbf{B}_{22} & 0 \\
    0 & -\mathbf{B}_{12} - \mathbf{B}_{22} & 0 & \mathbf{B}_{12} & 0 & \mathbf{B}_{22}
\end{bmatrix},
$$
where $\mathbf{B} = [\mathbf{X}_2 - \mathbf{X}_1, \mathbf{X}_3 - \mathbf{X}_1]^{-1}$ represents the inverse of the matrix formed by subtracting the first vertex from the second and third vertices. This matrix $\mathbf{B}$ can be precomputed at initialization along with other properties such as the volume and Lame parameters of each triangle:

{{imp}}{imp:lec15:elem_precomp}[Precomputation of element information, simulator.py]
```python
{{#include solid-sim-tutorial/6_inv_free/simulator.py:elem_precomp}}
```

The Young's modulus and Poisson's ratio:
```python
{{#include solid-sim-tutorial/6_inv_free/simulator.py:lame_param}}
```

Here, `e` no longer stores all edge elements as in mass-spring models but represents all triangle elements, which can be generated by modifying the meshing code as follows:

{{imp}}{imp:lec15:tri_vert_ind}[Assembling per-triangle vertex indices, square_mesh.py]
```python
{{#include solid-sim-tutorial/6_inv_free/square_mesh.py:tri_vert_ind}}
```

Triangles are arranged in a symmetric pattern and can be rendered by drawing the three edges:

{{imp}}{imp:lec15:draw_tri}[Draw triangles, simulator.py]
```python
{{#include solid-sim-tutorial/6_inv_free/simulator.py:draw_tri}}
```
