## Spatial and Temporal Discretizations

In representing solid geometries, we employ a mesh structure. We can further simplify the representation by connecting nodes on the mesh with edges. To facilitate this process, especially for geometries like squares, we can script a mesh generator. This generator allows for specifying both the side length of the square and the desired resolution of the mesh.


{{imp}}{imp:lec4:square_mesh}[Square Mesh Generation, square_mesh.py]
```python
{{#include solid-sim-tutorial/1_mass_spring/square_mesh.py:generate}}
```

In the code, `n_seg` represents the number of edges along each side of the square. The nodes are uniformly distributed across the square and interconnected through horizontal, vertical, and diagonal edges. For instance, calling `generate(1.0, 4)` constructs a mesh as depicted in {{ref: fig:lec4:square_mesh_4x4}}. This implementation utilizes the array data structures from the [Numpy](https://numpy.org/) library, which provides convenient methods for handling the vector algebra required in subsequent steps.

<figure>
    <center>
    <img src="img/lec4/square_mesh_4x4.jpg" width="200">
    </center>
    <figcaption><b>{{fig}}{fig:lec4:square_mesh_4x4}</b> A $4\times 4$ square mesh generated by calling <code>generate(1.0, 4)</code> defined in Square Mesh Generation script above. </figcaption>
</figure>

For temporal discretization, our approach is the implicit Euler method. The Incremental Potential, which needs to be minimized in time step \\(n\\), is represented as follows:
$$
    E(x) = \frac{1}{2}\|x - (x^n + h v^n)\|_M^2 + h^2 P(x).
    {{numeq}}{eq:lec4:IP}
$$
Next, our focus shifts to implementing the calculations for the energy value, gradient, and Hessian for both the inertia term and the potential energy \\(P(x)\\).
